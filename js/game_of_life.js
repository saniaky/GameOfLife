// Generated by CoffeeScript 1.7.1
var GameOfLife,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

GameOfLife = (function() {
  GameOfLife.prototype.numberOfRows = 200;

  GameOfLife.prototype.numberOfColumns = 200;

  GameOfLife.prototype.cellSize = 10;

  GameOfLife.prototype.refreshInterval = 10;

  GameOfLife.prototype.currentGeneration = null;

  GameOfLife.prototype.canvas = null;

  GameOfLife.prototype.canvasContext = null;

  GameOfLife.prototype.pause = true;

  GameOfLife.prototype.history = [];

  GameOfLife.prototype.history_size = 5000;

  GameOfLife.prototype.redrawPoints = [];

  function GameOfLife() {
    this.tick = __bind(this.tick, this);
    var opts;
    this.createCanvas();
    this.resizeCanvas();
    this.createContext();
    this.initGeneration();
    this.drawField();
    this.initButtons();
    opts = {
      distance: this.cellSize,
      lineWidth: 1.0,
      gridColor: 'rgb(210, 210, 210)',
      caption: false
    };
    new Grid(opts).draw(this.canvasContext);
  }

  GameOfLife.prototype.initButtons = function() {
    $("#play").click((function(_this) {
      return function(event) {
        return _this.playGame();
      };
    })(this));
    $("#pause").click((function(_this) {
      return function(event) {
        return _this.pauseGame();
      };
    })(this));
    $("#clear").click((function(_this) {
      return function(event) {
        return _this.clearGame();
      };
    })(this));
    return $("#canvasField").mousedown((function(_this) {
      return function(event) {
        var point;
        point = {
          column: Math.floor((event.pageX - $("#canvasField").offset().left) / _this.cellSize),
          row: Math.floor((event.pageY - $("#canvasField").offset().top) / _this.cellSize)
        };
        _this.currentGeneration[point.row][point.column].isAlive = !_this.currentGeneration[point.row][point.column].isAlive;
        _this.redrawPoints.push(point);
        return _this.tick();
      };
    })(this));
  };

  GameOfLife.prototype.playGame = function() {
    this.pause = false;
    this.tick();
    $("#play").attr({
      disabled: "disabled"
    });
    return $("#pause").removeAttr("disabled");
  };

  GameOfLife.prototype.pauseGame = function() {
    this.pause = true;
    $("#pause").attr({
      disabled: "disabled"
    });
    return $("#play").removeAttr("disabled");
  };

  GameOfLife.prototype.clearGame = function() {
    this.pauseGame();
    this.initGeneration();
    this.drawField();
    return this.history = [];
  };

  GameOfLife.prototype.createCanvas = function() {
    this.canvas = document.createElement('canvas');
    this.canvas.setAttribute("id", "canvasField");
    return document.getElementById('game').appendChild(this.canvas);
  };

  GameOfLife.prototype.createContext = function() {
    return this.canvasContext = this.canvas.getContext('2d');
  };

  GameOfLife.prototype.initGeneration = function() {
    var column, row, _i, _ref, _results;
    this.currentGeneration = [];
    _results = [];
    for (row = _i = 0, _ref = this.numberOfRows; 0 <= _ref ? _i <= _ref : _i >= _ref; row = 0 <= _ref ? ++_i : --_i) {
      this.currentGeneration[row] = [];
      _results.push((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (column = _j = 0, _ref1 = this.numberOfColumns; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          _results1.push(this.currentGeneration[row][column] = this.createCell(row, column));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  GameOfLife.prototype.createCell = function(row, column) {
    return {
      isAlive: false,
      row: row,
      column: column
    };
  };

  GameOfLife.prototype.resizeCanvas = function() {
    this.canvas.width = this.cellSize * this.numberOfColumns;
    return this.canvas.height = this.cellSize * this.numberOfRows;
  };

  GameOfLife.prototype.tick = function() {
    this.updateField();
    if (this.pause) {
      return;
    }
    this.calculateNextGeneration();
    return setTimeout(this.tick, this.refreshInterval);
  };

  GameOfLife.prototype.drawField = function() {
    var column, row, _i, _ref, _results;
    _results = [];
    for (row = _i = 0, _ref = this.numberOfRows; 0 <= _ref ? _i <= _ref : _i >= _ref; row = 0 <= _ref ? ++_i : --_i) {
      _results.push((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (column = _j = 0, _ref1 = this.numberOfColumns; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          _results1.push(this.drawCell(this.currentGeneration[row][column]));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  GameOfLife.prototype.updateField = function() {
    var p, _results;
    p = this.redrawPoints.pop();
    _results = [];
    while (!!p) {
      this.drawCell(this.currentGeneration[p.row][p.column]);
      _results.push(p = this.redrawPoints.pop());
    }
    return _results;
  };

  GameOfLife.prototype.drawCell = function(cell) {
    var fill, x, y;
    x = cell.column * this.cellSize;
    y = cell.row * this.cellSize;
    if (cell.isAlive) {
      fill = 'rgb(100, 200, 70)';
    } else {
      fill = 'rgb(250, 250, 250)';
    }
    this.canvasContext.fillStyle = fill;
    return this.canvasContext.fillRect(x + 1, y + 1, this.cellSize - 1, this.cellSize - 1);
  };

  GameOfLife.prototype.updateCellState = function(cell) {
    var newCell, sum;
    newCell = {
      row: cell.row,
      column: cell.column,
      isAlive: cell.isAlive
    };
    sum = this.countAliveCells(cell);
    if (cell.isAlive || sum === 3) {
      newCell.isAlive = (1 < sum && sum < 4);
    }
    return newCell;
  };

  GameOfLife.prototype.countAliveCells = function(cell) {
    var count, index, p, _i;
    p = [];
    p[1] = {
      row: cell.row - 1,
      column: cell.column - 1
    };
    p[2] = {
      row: cell.row - 1,
      column: cell.column
    };
    p[3] = {
      row: cell.row - 1,
      column: cell.column + 1
    };
    p[4] = {
      row: cell.row,
      column: cell.column - 1
    };
    p[5] = {
      row: cell.row,
      column: cell.column + 1
    };
    p[6] = {
      row: cell.row + 1,
      column: cell.column - 1
    };
    p[7] = {
      row: cell.row + 1,
      column: cell.column
    };
    p[8] = {
      row: cell.row + 1,
      column: cell.column + 1
    };
    if (cell.row - 1 < 0) {
      p[1].row = p[2].row = p[3].row = this.numberOfRows;
    }
    if (cell.column - 1 < 0) {
      p[1].column = p[4].column = p[6].column = this.numberOfColumns;
    }
    if (cell.row + 1 > this.numberOfRows) {
      p[6].row = p[7].row = p[8].row = 0;
    }
    if (cell.column + 1 > this.numberOfColumns) {
      p[3].column = p[5].column = p[8].column = 0;
    }
    count = 0;
    for (index = _i = 1; _i <= 8; index = ++_i) {
      if (this.currentGeneration[p[index].row][p[index].column].isAlive) {
        count++;
      }
    }
    return count;
  };

  GameOfLife.prototype.isCycleDetected = function() {
    var _ref;
    return _ref = this.getCurrentSha(), __indexOf.call(this.history, _ref) >= 0;
  };

  GameOfLife.prototype.calculateNextGeneration = function() {
    var cell, column, nextGeneration, point, row, _i, _j, _ref, _ref1;
    if (this.isCycleDetected()) {
      alert('Cycle is found (' + this.history.length + ' generations)');
      console.log(this.getCurrentSha());
      this.pauseGame();
      return;
    }
    this.history.push(this.getCurrentSha());
    if (this.history.length > this.history_size) {
      this.history.shift;
    }
    nextGeneration = [];
    for (row = _i = 0, _ref = this.numberOfRows; 0 <= _ref ? _i <= _ref : _i >= _ref; row = 0 <= _ref ? ++_i : --_i) {
      nextGeneration[row] = [];
      for (column = _j = 0, _ref1 = this.numberOfColumns; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
        cell = this.updateCellState(this.currentGeneration[row][column]);
        nextGeneration[row][column] = cell;
        if (cell.isAlive !== this.currentGeneration[row][column].isAlive) {
          point = {
            row: row,
            column: column
          };
          this.redrawPoints.push(point);
        }
      }
    }
    return this.currentGeneration = nextGeneration;
  };

  GameOfLife.prototype.getCurrentSha = function() {
    var buffer, column, hash, row, _i, _j, _ref, _ref1;
    buffer = '';
    for (row = _i = 0, _ref = this.numberOfRows; 0 <= _ref ? _i <= _ref : _i >= _ref; row = 0 <= _ref ? ++_i : --_i) {
      for (column = _j = 0, _ref1 = this.numberOfColumns; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
        buffer += this.currentGeneration[row][column].isAlive;
      }
    }
    return hash = CryptoJS.SHA1(buffer).toString(CryptoJS.enc.Base64);
  };

  return GameOfLife;

})();
